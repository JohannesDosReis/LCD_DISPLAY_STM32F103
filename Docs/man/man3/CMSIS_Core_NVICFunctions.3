.TH "CMSIS_Core_NVICFunctions" 3 "Thu Oct 29 2020" "lcd_display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CMSIS_Core_NVICFunctions \- Functions that manage interrupts and exceptions via the NVIC\&.  

.SH SYNOPSIS
.br
.PP
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBFPU Functions\fP"
.br
.RI "Function that provides FPU type\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_EnableIRQ\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Enable Interrupt\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fB__NVIC_GetEnableIRQ\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Get Interrupt Enable status\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_DisableIRQ\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Disable Interrupt\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fB__NVIC_GetPendingIRQ\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Get Pending Interrupt\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_SetPendingIRQ\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Set Pending Interrupt\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_ClearPendingIRQ\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Clear Pending Interrupt\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fB__NVIC_GetActive\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Get Active Interrupt\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_SetPriority\fP (\fBIRQn_Type\fP IRQn, uint32_t priority)"
.br
.RI "Set Interrupt Priority\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fB__NVIC_GetPriority\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Get Interrupt Priority\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fBNVIC_EncodePriority\fP (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)"
.br
.RI "Encode Priority\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBNVIC_DecodePriority\fP (uint32_t Priority, uint32_t PriorityGroup, uint32_t *const pPreemptPriority, uint32_t *const pSubPriority)"
.br
.RI "Decode Priority\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_SetVector\fP (\fBIRQn_Type\fP IRQn, uint32_t vector)"
.br
.RI "Set Interrupt Vector\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fB__NVIC_GetVector\fP (\fBIRQn_Type\fP IRQn)"
.br
.RI "Get Interrupt Vector\&. "
.ti -1c
.RI "\fB__NO_RETURN\fP \fB__STATIC_INLINE\fP void \fB__NVIC_SystemReset\fP (void)"
.br
.RI "System Reset\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fBSCB_GetFPUType\fP (void)"
.br
.RI "get FPU type "
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBFNC_RETURN\fP   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_PREFIX\fP   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_S\fP   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_DCRS\fP   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_FTYPE\fP   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_MODE\fP   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_SPSEL\fP   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_ES\fP   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"
.br
.ti -1c
.RI "#define \fBEXC_INTEGRITY_SIGNATURE\fP   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"
.br
.ti -1c
.RI "#define \fB_BIT_SHIFT\fP(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"
.br
.ti -1c
.RI "#define \fB_SHP_IDX\fP(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB_IP_IDX\fP(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB__NVIC_SetPriorityGrouping\fP(X)   (void)(X)"
.br
.ti -1c
.RI "#define \fB__NVIC_GetPriorityGrouping\fP()   (0U)"
.br
.RI "Get Priority Grouping\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fB__NVIC_SetPriorityGrouping\fP (uint32_t PriorityGroup)"
.br
.RI "Set Priority Grouping\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fB__NVIC_GetPriorityGrouping\fP (void)"
.br
.RI "Get Priority Grouping\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP uint32_t \fBITM_SendChar\fP (uint32_t ch)"
.br
.RI "ITM Send Character\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP int32_t \fBITM_ReceiveChar\fP (void)"
.br
.RI "ITM Receive Character\&. "
.ti -1c
.RI "\fB__STATIC_INLINE\fP int32_t \fBITM_CheckChar\fP (void)"
.br
.RI "ITM Check Character\&. "
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBFNC_RETURN\fP   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_PREFIX\fP   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_S\fP   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_DCRS\fP   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_FTYPE\fP   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_MODE\fP   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_SPSEL\fP   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_ES\fP   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"
.br
.ti -1c
.RI "#define \fBEXC_INTEGRITY_SIGNATURE\fP   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.ti -1c
.RI "#define \fB_BIT_SHIFT\fP(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"
.br
.ti -1c
.RI "#define \fB_SHP_IDX\fP(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB_IP_IDX\fP(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB__NVIC_SetPriorityGrouping\fP(X)   (void)(X)"
.br
.ti -1c
.RI "#define \fB__NVIC_GetPriorityGrouping\fP()   (0U)"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.ti -1c
.RI "#define \fB_BIT_SHIFT\fP(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"
.br
.ti -1c
.RI "#define \fB_SHP_IDX\fP(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB_IP_IDX\fP(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB__NVIC_SetPriorityGrouping\fP(X)   (void)(X)"
.br
.ti -1c
.RI "#define \fB__NVIC_GetPriorityGrouping\fP()   (0U)"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.ti -1c
.RI "#define \fB_BIT_SHIFT\fP(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"
.br
.ti -1c
.RI "#define \fB_SHP_IDX\fP(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB_IP_IDX\fP(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB__NVIC_SetPriorityGrouping\fP(X)   (void)(X)"
.br
.ti -1c
.RI "#define \fB__NVIC_GetPriorityGrouping\fP()   (0U)"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBFNC_RETURN\fP   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_PREFIX\fP   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_S\fP   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_DCRS\fP   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_FTYPE\fP   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_MODE\fP   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_SPSEL\fP   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_ES\fP   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"
.br
.ti -1c
.RI "#define \fBEXC_INTEGRITY_SIGNATURE\fP   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"
.br
.ti -1c
.RI "#define \fB_BIT_SHIFT\fP(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"
.br
.ti -1c
.RI "#define \fB_SHP_IDX\fP(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB_IP_IDX\fP(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB__NVIC_SetPriorityGrouping\fP(X)   (void)(X)"
.br
.ti -1c
.RI "#define \fB__NVIC_GetPriorityGrouping\fP()   (0U)"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBFNC_RETURN\fP   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_PREFIX\fP   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_S\fP   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_DCRS\fP   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_FTYPE\fP   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_MODE\fP   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_SPSEL\fP   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_ES\fP   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"
.br
.ti -1c
.RI "#define \fBEXC_INTEGRITY_SIGNATURE\fP   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER_FPU\fP   (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating\-point state */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP_FPU\fP   (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating\-point state  */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP_FPU\fP   (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating\-point state  */"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER_FPU\fP   (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating\-point state */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP_FPU\fP   (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating\-point state  */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP_FPU\fP   (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating\-point state  */"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.ti -1c
.RI "#define \fB_BIT_SHIFT\fP(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"
.br
.ti -1c
.RI "#define \fB_SHP_IDX\fP(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"
.br
.ti -1c
.RI "#define \fB_IP_IDX\fP(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"
.br
.in -1c
.in +1c
.ti -1c
.RI "#define \fBNVIC_SetPriorityGrouping\fP   \fB__NVIC_SetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriorityGrouping\fP   \fB__NVIC_GetPriorityGrouping\fP"
.br
.ti -1c
.RI "#define \fBNVIC_EnableIRQ\fP   \fB__NVIC_EnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetEnableIRQ\fP   \fB__NVIC_GetEnableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_DisableIRQ\fP   \fB__NVIC_DisableIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPendingIRQ\fP   \fB__NVIC_GetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPendingIRQ\fP   \fB__NVIC_SetPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_ClearPendingIRQ\fP   \fB__NVIC_ClearPendingIRQ\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetActive\fP   \fB__NVIC_GetActive\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetPriority\fP   \fB__NVIC_SetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetPriority\fP   \fB__NVIC_GetPriority\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SystemReset\fP   \fB__NVIC_SystemReset\fP"
.br
.ti -1c
.RI "#define \fBNVIC_SetVector\fP   \fB__NVIC_SetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_GetVector\fP   \fB__NVIC_GetVector\fP"
.br
.ti -1c
.RI "#define \fBNVIC_USER_IRQ_OFFSET\fP   16"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_HANDLER\fP   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_MSP\fP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"
.br
.ti -1c
.RI "#define \fBEXC_RETURN_THREAD_PSP\fP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions that manage interrupts and exceptions via the NVIC\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define __NVIC_GetPriorityGrouping(void)   (0U)"

.SS "#define __NVIC_GetPriorityGrouping(void)   (0U)"

.SS "#define __NVIC_GetPriorityGrouping(void)   (0U)"

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetPriorityGrouping(void)   (0U)"

.PP
Get Priority Grouping\&. Reads the priority grouping field from the NVIC Interrupt Controller\&. 
.PP
\fBReturns\fP
.RS 4
Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)\&. 
.RE
.PP

.SS "#define __NVIC_GetPriorityGrouping(void)   (0U)"

.SS "#define __NVIC_SetPriorityGrouping(X)   (void)(X)"

.SS "#define __NVIC_SetPriorityGrouping(X)   (void)(X)"

.SS "#define __NVIC_SetPriorityGrouping(X)   (void)(X)"

.SS "#define __NVIC_SetPriorityGrouping(X)   (void)(X)"

.SS "#define __NVIC_SetPriorityGrouping(X)   (void)(X)"

.SS "#define _BIT_SHIFT(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"

.SS "#define _BIT_SHIFT(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"

.SS "#define _BIT_SHIFT(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"

.SS "#define _BIT_SHIFT(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"

.SS "#define _BIT_SHIFT(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"

.SS "#define _BIT_SHIFT(IRQn)   (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)"

.SS "#define _IP_IDX(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"

.SS "#define _IP_IDX(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"

.SS "#define _IP_IDX(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"

.SS "#define _IP_IDX(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"

.SS "#define _IP_IDX(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"

.SS "#define _IP_IDX(IRQn)   (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )"

.SS "#define _SHP_IDX(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"

.SS "#define _SHP_IDX(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"

.SS "#define _SHP_IDX(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"

.SS "#define _SHP_IDX(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"

.SS "#define _SHP_IDX(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"

.SS "#define _SHP_IDX(IRQn)   ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)\-8UL) >>    2UL)      )"

.SS "#define EXC_INTEGRITY_SIGNATURE   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"

.SS "#define EXC_INTEGRITY_SIGNATURE   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"

.SS "#define EXC_INTEGRITY_SIGNATURE   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"

.SS "#define EXC_INTEGRITY_SIGNATURE   (0xFEFA125BUL)     /* Value for processors without floating\-point extension                */"

.SS "#define EXC_RETURN_DCRS   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"

.SS "#define EXC_RETURN_DCRS   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"

.SS "#define EXC_RETURN_DCRS   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"

.SS "#define EXC_RETURN_DCRS   (0x00000020UL)     /* bit [5] stacking rules for called registers: 0=skipped 1=saved       */"

.SS "#define EXC_RETURN_ES   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"

.SS "#define EXC_RETURN_ES   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"

.SS "#define EXC_RETURN_ES   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"

.SS "#define EXC_RETURN_ES   (0x00000001UL)     /* bit [0] security state exception was taken to: 0=Non\-secure 1=Secure */"

.SS "#define EXC_RETURN_FTYPE   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"

.SS "#define EXC_RETURN_FTYPE   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"

.SS "#define EXC_RETURN_FTYPE   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"

.SS "#define EXC_RETURN_FTYPE   (0x00000010UL)     /* bit [4] allocate stack for floating\-point context: 0=done 1=skipped  */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER   (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */"

.SS "#define EXC_RETURN_HANDLER_FPU   (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating\-point state */"

.SS "#define EXC_RETURN_HANDLER_FPU   (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating\-point state */"

.SS "#define EXC_RETURN_MODE   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"

.SS "#define EXC_RETURN_MODE   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"

.SS "#define EXC_RETURN_MODE   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"

.SS "#define EXC_RETURN_MODE   (0x00000008UL)     /* bit [3] processor mode for return: 0=Handler mode 1=Thread mode      */"

.SS "#define EXC_RETURN_PREFIX   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"

.SS "#define EXC_RETURN_PREFIX   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"

.SS "#define EXC_RETURN_PREFIX   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"

.SS "#define EXC_RETURN_PREFIX   (0xFF000000UL)     /* bits [31:24] set to indicate an EXC_RETURN value                     */"

.SS "#define EXC_RETURN_S   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"

.SS "#define EXC_RETURN_S   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"

.SS "#define EXC_RETURN_S   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"

.SS "#define EXC_RETURN_S   (0x00000040UL)     /* bit [6] stack used to push registers: 0=Non\-secure 1=Secure          */"

.SS "#define EXC_RETURN_SPSEL   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"

.SS "#define EXC_RETURN_SPSEL   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"

.SS "#define EXC_RETURN_SPSEL   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"

.SS "#define EXC_RETURN_SPSEL   (0x00000002UL)     /* bit [1] stack pointer used to restore context: 0=MSP 1=PSP           */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP   (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */"

.SS "#define EXC_RETURN_THREAD_MSP_FPU   (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating\-point state  */"

.SS "#define EXC_RETURN_THREAD_MSP_FPU   (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating\-point state  */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP   (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */"

.SS "#define EXC_RETURN_THREAD_PSP_FPU   (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating\-point state  */"

.SS "#define EXC_RETURN_THREAD_PSP_FPU   (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating\-point state  */"

.SS "#define FNC_RETURN   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"

.SS "#define FNC_RETURN   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"

.SS "#define FNC_RETURN   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"

.SS "#define FNC_RETURN   (0xFEFFFFFFUL)     /* bit [0] ignored when processing a branch                             */"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_ClearPendingIRQ   \fB__NVIC_ClearPendingIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_DisableIRQ   \fB__NVIC_DisableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_EnableIRQ   \fB__NVIC_EnableIRQ\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetActive   \fB__NVIC_GetActive\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetEnableIRQ   \fB__NVIC_GetEnableIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPendingIRQ   \fB__NVIC_GetPendingIRQ\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriority   \fB__NVIC_GetPriority\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetPriorityGrouping   \fB__NVIC_GetPriorityGrouping\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_GetVector   \fB__NVIC_GetVector\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPendingIRQ   \fB__NVIC_SetPendingIRQ\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriority   \fB__NVIC_SetPriority\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetPriorityGrouping   \fB__NVIC_SetPriorityGrouping\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SetVector   \fB__NVIC_SetVector\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_SystemReset   \fB__NVIC_SystemReset\fP"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SS "#define NVIC_USER_IRQ_OFFSET   16"

.SH "Function Documentation"
.PP 
.SS "\fB__STATIC_INLINE\fP void __NVIC_ClearPendingIRQ (\fBIRQn_Type\fP IRQn)"

.PP
Clear Pending Interrupt\&. Clears the pending bit of a device specific interrupt in the NVIC pending register\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void __NVIC_DisableIRQ (\fBIRQn_Type\fP IRQn)"

.PP
Disable Interrupt\&. Disables a device specific interrupt in the NVIC interrupt controller\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void __NVIC_EnableIRQ (\fBIRQn_Type\fP IRQn)"

.PP
Enable Interrupt\&. Enables a device specific interrupt in the NVIC interrupt controller\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetActive (\fBIRQn_Type\fP IRQn)"

.PP
Get Active Interrupt\&. Reads the active register in the NVIC and returns the active bit for the device specific interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 Interrupt status is not active\&. 
.PP
1 Interrupt status is active\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetEnableIRQ (\fBIRQn_Type\fP IRQn)"

.PP
Get Interrupt Enable status\&. Returns a device specific interrupt enable status from the NVIC interrupt controller\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 Interrupt is not enabled\&. 
.PP
1 Interrupt is enabled\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetPendingIRQ (\fBIRQn_Type\fP IRQn)"

.PP
Get Pending Interrupt\&. Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 Interrupt status is not pending\&. 
.PP
1 Interrupt status is pending\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetPriority (\fBIRQn_Type\fP IRQn)"

.PP
Get Interrupt Priority\&. Reads the priority of a device specific interrupt or a processor exception\&. The interrupt number can be positive to specify a device specific interrupt, or negative to specify a processor exception\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Interrupt number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Interrupt Priority\&. Value is aligned automatically to the implemented priority bits of the microcontroller\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetPriorityGrouping (void)"

.PP
Get Priority Grouping\&. Reads the priority grouping field from the NVIC Interrupt Controller\&. 
.PP
\fBReturns\fP
.RS 4
Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t __NVIC_GetVector (\fBIRQn_Type\fP IRQn)"

.PP
Get Interrupt Vector\&. Reads an interrupt vector from interrupt vector table\&. The interrupt number can be positive to specify a device specific interrupt, or negative to specify a processor exception\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Interrupt number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Address of interrupt handler function 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void __NVIC_SetPendingIRQ (\fBIRQn_Type\fP IRQn)"

.PP
Set Pending Interrupt\&. Sets the pending bit of a device specific interrupt in the NVIC pending register\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Device specific interrupt number\&. 
.RE
.PP
\fBNote\fP
.RS 4
IRQn must not be negative\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void __NVIC_SetPriority (\fBIRQn_Type\fP IRQn, uint32_t priority)"

.PP
Set Interrupt Priority\&. Sets the priority of a device specific interrupt or a processor exception\&. The interrupt number can be positive to specify a device specific interrupt, or negative to specify a processor exception\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Interrupt number\&. 
.br
\fIpriority\fP Priority to set\&. 
.RE
.PP
\fBNote\fP
.RS 4
The priority cannot be set for every processor exception\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void __NVIC_SetPriorityGrouping (uint32_t PriorityGroup)"

.PP
Set Priority Grouping\&. Sets the priority grouping field using the required unlock sequence\&. The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field\&. Only values from 0\&.\&.7 are used\&. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set\&. 
.PP
\fBParameters\fP
.RS 4
\fIPriorityGroup\fP Priority grouping field\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void __NVIC_SetVector (\fBIRQn_Type\fP IRQn, uint32_t vector)"

.PP
Set Interrupt Vector\&. Sets an interrupt vector in SRAM based interrupt vector table\&. The interrupt number can be positive to specify a device specific interrupt, or negative to specify a processor exception\&. VTOR must been relocated to SRAM before\&. If VTOR is not present address 0 must be mapped to SRAM\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Interrupt number 
.br
\fIvector\fP Address of interrupt handler function
.RE
.PP
Sets an interrupt vector in SRAM based interrupt vector table\&. The interrupt number can be positive to specify a device specific interrupt, or negative to specify a processor exception\&. VTOR must been relocated to SRAM before\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Interrupt number 
.br
\fIvector\fP Address of interrupt handler function
.RE
.PP
Sets an interrupt vector in SRAM based interrupt vector table\&. The interrupt number can be positive to specify a device specific interrupt, or negative to specify a processor exception\&. Address 0 must be mapped to SRAM\&. 
.PP
\fBParameters\fP
.RS 4
\fIIRQn\fP Interrupt number 
.br
\fIvector\fP Address of interrupt handler function 
.RE
.PP

.SS "\fB__NO_RETURN\fP \fB__STATIC_INLINE\fP void __NVIC_SystemReset (void)"

.PP
System Reset\&. Initiates a system reset request to reset the MCU\&. 
.SS "\fB__STATIC_INLINE\fP int32_t ITM_CheckChar (void)"

.PP
ITM Check Character\&. Checks whether a character is pending for reading in the variable \fBITM_RxBuffer\fP\&. 
.PP
\fBReturns\fP
.RS 4
0 No character available\&. 
.PP
1 Character available\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP int32_t ITM_ReceiveChar (void)"

.PP
ITM Receive Character\&. Inputs a character via the external variable \fBITM_RxBuffer\fP\&. 
.PP
\fBReturns\fP
.RS 4
Received character\&. 
.PP
-1 No character pending\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t ITM_SendChar (uint32_t ch)"

.PP
ITM Send Character\&. Transmits a character via the ITM channel 0, and 
.PD 0

.IP "\(bu" 2
Just returns when no debugger is connected that has booked the output\&. 
.IP "\(bu" 2
Is blocking when a debugger is connected, but the previous character sent has not been transmitted\&. 
.PP
\fBParameters\fP
.RS 4
\fIch\fP Character to transmit\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Character to transmit\&. 
.RE
.PP

.PP

.SS "\fB__STATIC_INLINE\fP void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t *const pPreemptPriority, uint32_t *const pSubPriority)"

.PP
Decode Priority\&. Decodes an interrupt priority value with a given priority group to preemptive priority value and subpriority value\&. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set\&. 
.PP
\fBParameters\fP
.RS 4
\fIPriority\fP Priority value, which can be retrieved with the function \fBNVIC_GetPriority()\fP\&. 
.br
\fIPriorityGroup\fP Used priority group\&. 
.br
\fIpPreemptPriority\fP Preemptive priority value (starting from 0)\&. 
.br
\fIpSubPriority\fP Subpriority value (starting from 0)\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)"

.PP
Encode Priority\&. Encodes the priority for an interrupt with the given priority group, preemptive priority value, and subpriority value\&. In case of a conflict between priority grouping and available priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set\&. 
.PP
\fBParameters\fP
.RS 4
\fIPriorityGroup\fP Used priority group\&. 
.br
\fIPreemptPriority\fP Preemptive priority value (starting from 0)\&. 
.br
\fISubPriority\fP Subpriority value (starting from 0)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Encoded priority\&. Value can be used in the function \fBNVIC_SetPriority()\fP\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP uint32_t SCB_GetFPUType (void)"

.PP
get FPU type returns the FPU type 
.PP
\fBReturns\fP
.RS 4

.IP "\(bu" 2
\fB0\fP: No FPU
.IP "\(bu" 2
\fB1\fP: Single precision FPU
.IP "\(bu" 2
\fB2\fP: Double + Single precision FPU 
.PP
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for lcd_display from the source code\&.
